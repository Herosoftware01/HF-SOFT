{% extends 'mains.html' %}
{% load static %}
{% block content %}

<!-- AG Grid CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community/styles/ag-grid.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community/styles/ag-theme-alpine.css" />

<style>
      .ag-theme-alpine .ag-cell[col-id="img_fpath"] {
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    padding: 0 !important;
  }
 
    /* Cell focused (selected cell) */
    .ag-cell-focus {
      outline: none !important; /* remove default focus ring */
      background-color: #fbbf24 !important; /* Tailwind yellow-400 */
      color: black !important;
      font-weight: bold;
    }

    /* Highlight only matched text inside cell */
    .search-highlight {
      background-color: #facc15; /* Tailwind yellow-400 */
      color: black;
      font-weight: bold;
      padding: 0 2px;
      border-radius: 2px;
    }

    #myGrid {
      height: 700px;
      width: auto;
      max-width: 100vw; /* don't overflow viewport */
      box-sizing: border-box;
      overflow-x: auto; /* allow horizontal scroll on small screens */
    }

    /* Optional: hide horizontal scrollbar nicely */
    #myGrid::-webkit-scrollbar {
      height: 8px;
    }
    #myGrid::-webkit-scrollbar-thumb {
      background: #cbd5e1; /* Tailwind slate-300 */
      border-radius: 4px;
    }

</style>
<div class="bg-gray-100 p-6 container mx-auto justify-center">

  <h1 class="text-2xl font-semibold mb-4 text-end">Fabric Data Table</h1>

  <!-- Global filter input -->
  <input
    type="text"
    id="globalFilter"
    placeholder="Search all columns..."
    class="mb-4 p-2 border border-gray-300 rounded w-full max-w-md"
  />
<div id="rowCount" class="py-2 text-gray-700 font-semibold text-end"></div>
  <div class="overflow-auto w-full max-w-full">
    <div id="myGrid" class="ag-theme-alpine shadow-lg rounded-lg" style="min-width: 1000px;"></div>
    </div>



  <!-- AG Grid JS -->
  <script src="https://cdn.jsdelivr.net/npm/ag-grid-community@29.3.2/dist/ag-grid-community.min.noStyle.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const existingDataMap = new Map();
  const gridDiv = document.querySelector('#myGrid');

  // Utility: Highlight matching text
  const highlightMatch = (value, filterText) => {
    if (!filterText) return value;
    const regex = new RegExp(`(${filterText})`, 'gi');
    return String(value).replace(regex, '<span class="search-highlight">$1</span>');
  };

  // Custom cell renderer
  const createRenderer = (field) => {
    return (params) => {
      const globalText = document.getElementById('globalFilter').value.toLowerCase();
      const colFilterModel = params.api.getFilterModel()[field];
      let matchText = '';

      // Prioritize column filter
      if (colFilterModel && colFilterModel.filter) {
        matchText = colFilterModel.filter.toLowerCase();
      } else if (globalText) {
        matchText = globalText;
      }

      return matchText
        ? highlightMatch(params.value, matchText)
        : params.value;
    };
  };

  // Column Definitions with cellRenderer
  const columnDefs = [
    { headerName: 'buyerid', field: 'buyerid', cellRenderer: createRenderer('buyerid'), filter: 'agTextColumnFilter', floatingFilter: true },
    {
  headerName: 'All',
  field: 'buyername', // Needed for filtering (can be any field)
  valueGetter: (params) => {
    const orderno = params.data.orderno ?? '';
    const buyername = params.data.buyername ?? '';
    const refresh = params.data.refresh ?? '';
    return `${orderno} ${buyername} ${refresh}`;
  },
  cellRenderer: (params) => {
    const orderno = highlightRenderer({ ...params, value: params.data.orderno });
    const buyername = highlightRenderer({ ...params, value: params.data.buyername });
    const refresh = highlightRenderer({ ...params, value: params.data.refresh });

    return `<div class="multi-line-cell">
      <div><strong>${orderno}</strong></div>
      <div>${buyername}</div>
      <div>${refresh}</div>
    </div>`;
  },
  filter: 'agTextColumnFilter',
  floatingFilter: true,
  autoHeight: true,
  flex: 2,
  minWidth: 200,
},

    { headerName: 'buyername', field: 'buyername', cellRenderer: createRenderer('buyername'), filter: 'agTextColumnFilter', floatingFilter: true },
    { headerName: 'orderno', field: 'orderno', cellRenderer: createRenderer('orderno'), filter: 'agTextColumnFilter', floatingFilter: true },
    { headerName: 'date', field: 'date', cellRenderer: createRenderer('date'), filter: 'agTextColumnFilter', floatingFilter: true },
    { headerName: 'guid', field: 'guid', cellRenderer: createRenderer('guid'), filter: 'agTextColumnFilter', floatingFilter: true },
    { headerName: 'refresh', field: 'refresh', cellRenderer: createRenderer('refresh'), filter: 'agTextColumnFilter', floatingFilter: true },
  ];

  const gridOptions = {
    columnDefs,
    defaultColDef: {
      sortable: true,
      filter: true,
      floatingFilter: true,
      flex: 1,
      minWidth: 120,
      resizable: true,
    },
    rowSelection: 'multiple',
    animateRows: true,
    getRowId: params => params.data.buyerid,
    rowData: [],
    onFilterChanged: () => {
      // Force refresh renderers when filters change
      gridOptions.api.refreshCells({ force: true });
    },
  };

  new agGrid.Grid(gridDiv, gridOptions);

  async function fetchData() {
    try {
      const response = await fetch('/web_socket/');
      const newData = await response.json();

      const inserts = [];
      const updates = [];

      for (const row of newData) {
        const oldRow = existingDataMap.get(row.buyerid);
        const newString = JSON.stringify(row);

        if (!oldRow) {
          inserts.push(row);
        } else if (JSON.stringify(oldRow) !== newString) {
          updates.push(row);
        }

        existingDataMap.set(row.buyerid, row);
      }

      if (inserts.length || updates.length) {
        gridOptions.api.applyTransaction({ add: inserts, update: updates });
        document.getElementById('rowCount').textContent = `Total Rows: ${existingDataMap.size}`;
        gridOptions.api.refreshCells({ force: true });
      }
    } catch (error) {
      console.error('Error fetching buyers:', error);
    }
  }

  function highlightRenderer(params) {
  const globalText = document.getElementById('globalFilter')?.value?.toLowerCase() || '';
  const colFilterModel = params.api.getFilterModel()[params.colDef.field];
  let matchText = '';

  if (colFilterModel && colFilterModel.filter) {
    matchText = colFilterModel.filter.toLowerCase();
  } else if (globalText) {
    matchText = globalText;
  }

  if (!matchText || !params.value) return params.value;

  const regex = new RegExp(`(${matchText})`, 'gi');
  return String(params.value).replace(regex, '<span class="search-highlight">$1</span>');
}

  // Global filter input
  document.querySelector('#globalFilter').addEventListener('input', e => {
    gridOptions.api.setQuickFilter(e.target.value);
    gridOptions.api.refreshCells({ force: true });
  });

  fetchData();
  setInterval(fetchData, 2000);
});
</script>

{% endblock %}
